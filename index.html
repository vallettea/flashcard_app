<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language Flashcard App</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        nav { margin-bottom: 20px; }
        nav button { margin-right: 10px; }
        section { display: none; margin-bottom: 20px; }
        section.active { display: block; }
        button { margin-right: 10px; }
        ul { list-style: none; padding: 0; }
        li { margin-bottom: 10px; border: 1px solid #ddd; padding: 10px; }
        .group-item { cursor: move; touch-action: none; } /* For better touch */
        .flashcard { border: 1px solid #000; padding: 20px; text-align: center; min-height: 200px; }
        .front, .back { display: none; }
        .active { display: block; }
        audio, video { margin: 10px 0; }
        img { max-width: 100%; height: auto; }
        #group-datalist { position: absolute; background: white; border: 1px solid #ddd; max-height: 150px; overflow-y: auto; }
        #message-banner { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: green; color: white; padding: 10px; border-radius: 5px; display: none; z-index: 1000; }
    </style>
</head>
<body>
    <h1>Language Flashcard App</h1>

    <nav>
        <button onclick="showSection('import-section')">Load JSON</button>
        <button onclick="showSection('items-section')">Associate Images & Groups</button>
        <button onclick="showSection('groups-section')">Manage Groups & Order</button>
        <button onclick="showSection('learning-section')">Train</button>
    </nav>

    <section id="import-section">
        <h2>Import JSON Data</h2>
        <textarea id="json-input" rows="10" cols="50" placeholder="Paste your JSON array here..."></textarea>
        <button onclick="importData()">Import</button>
        <h2>Export Data</h2>
        <button onclick="exportData()">Export to Clipboard</button>
        <textarea id="export-output" rows="10" cols="50" readonly></textarea>
    </section>

    <section id="items-section">
        <h2>All Items - Associate Images & Add to Groups</h2>
        <button onclick="generateAllMissingImages()">Generate AI Images for All Missing</button>
        <ul id="all-items"></ul>
    </section>

    <section id="groups-section">
        <h2>Manage Groups</h2>
        <div id="groups-container"></div>
    </section>

    <section id="learning-section">
        <h2>Learn a Group</h2>
        <select id="group-select"></select>
        <select id="mode-select">
            <option value="image">Image</option>
            <option value="chinese">Chinese Characters</option>
            <option value="pinyin">Pinyin</option>
        </select>
        <button onclick="startSession()">Start Session</button>
        <div id="flashcard-container" style="display: none;">
            <div class="flashcard" onclick="flipCard()">
                <div class="front active"></div>
                <div class="back"></div>
            </div>
            <button onclick="markCorrect()">Correct</button>
            <button onclick="markIncorrect()">Incorrect</button>
            <p id="progress"></p>
        </div>
        <div id="session-result" style="display: none;"></div>
    </section>

    <div id="message-banner"></div>

    <script>
        let allItems = [];
        let groups = {};
        const storageKey = 'flashcardAppData';
        const aiImageApiUrl = 'https://image.pollinations.ai/prompt/';

        // Load saved data from localStorage
        function loadData() {
            const saved = localStorage.getItem(storageKey);
            if (saved) {
                const data = JSON.parse(saved);
                allItems = data.items || [];
                groups = data.groups || {};
                renderAllItems();
                renderGroups();
                populateGroupSelect();
            }
        }

        // Save data to localStorage
        function saveData() {
            localStorage.setItem(storageKey, JSON.stringify({ items: allItems, groups }));
        }

        // Show specific section
        function showSection(id) {
            document.querySelectorAll('section').forEach(sec => sec.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            if (id === 'groups-section') renderGroups();
            if (id === 'items-section') renderAllItems();
            if (id === 'learning-section') populateGroupSelect();
        }

        // Import JSON data (append or update)
        function importData() {
            const jsonInput = document.getElementById('json-input').value;
            try {
                const imported = JSON.parse(jsonInput);
                const idMap = new Map(allItems.map(item => [item.learnable_id, item]));
                imported.forEach(newItem => {
                    const existing = idMap.get(newItem.learnable_id);
                    if (existing) {
                        // Update existing item
                        Object.assign(existing, newItem);
                        existing.image = existing.image || null; // Preserve image if not in import
                    } else {
                        // Append new item
                        allItems.push({ ...newItem, image: null });
                    }
                });
                renderAllItems();
                saveData();
                showMessage('Data imported successfully (appended/updated)!');
            } catch (e) {
                showMessage('Invalid JSON!', 'red');
            }
        }

        // Export data to clipboard and textarea
        function exportData() {
            const data = JSON.stringify({ items: allItems, groups }, null, 2);
            document.getElementById('export-output').value = data;
            navigator.clipboard.writeText(data).then(() => {
                showMessage('Data exported to clipboard!');
            }).catch(() => {
                showMessage('Failed to copy to clipboard. Use the textarea.', 'red');
            });
        }

        // Show vanishing message banner
        function showMessage(text, color = 'green') {
            const banner = document.getElementById('message-banner');
            banner.textContent = text;
            banner.style.background = color;
            banner.style.display = 'block';
            setTimeout(() => {
                banner.style.display = 'none';
            }, 3000);
        }

        // Render all items list
        function renderAllItems() {
            const ul = document.getElementById('all-items');
            ul.innerHTML = '';
            allItems.forEach(item => {
                const li = document.createElement('li');
                li.textContent = `${item.source_value} - ${item.target_value}`;
                li.dataset.id = item.learnable_id;

                // Add to group input with autocomplete
                const groupInput = document.createElement('input');
                groupInput.type = 'text';
                groupInput.placeholder = 'Group name (autocomplete)';
                groupInput.setAttribute('list', 'group-datalist');
                li.appendChild(groupInput);

                const addBtn = document.createElement('button');
                addBtn.textContent = 'Add/Create Group';
                addBtn.onclick = () => addToGroup(item.learnable_id, groupInput.value.trim());
                li.appendChild(addBtn);

                // Generate AI Image button
                const genBtn = document.createElement('button');
                genBtn.textContent = 'Generate AI Image';
                genBtn.onclick = () => generateAIImage(item.learnable_id);
                li.appendChild(genBtn);

                // Upload image
                const uploadInput = document.createElement('input');
                uploadInput.type = 'file';
                uploadInput.accept = 'image/*';
                uploadInput.onchange = (e) => uploadImage(item.learnable_id, e.target.files[0]);
                li.appendChild(uploadInput);

                // Preview if image exists
                if (item.image) {
                    const preview = document.createElement('img');
                    preview.src = item.image;
                    preview.style.maxWidth = '100px';
                    li.appendChild(preview);
                }

                ul.appendChild(li);
            });
            updateDatalist();
        }

        // Update datalist with current groups
        function updateDatalist() {
            let datalist = document.getElementById('group-datalist');
            if (!datalist) {
                datalist = document.createElement('datalist');
                datalist.id = 'group-datalist';
                document.body.appendChild(datalist);
            }
            datalist.innerHTML = Object.keys(groups).map(name => `<option value="${name}">`).join('');
        }

        // Add to group, create if not exists
        function addToGroup(id, groupName) {
            if (!groupName) return showMessage('Enter a group name!', 'red');
            const isNew = !groups[groupName];
            if (isNew) {
                groups[groupName] = [];
            }
            if (!groups[groupName].includes(id)) {
                groups[groupName].push(id);
                renderGroups();
                populateGroupSelect();
                if (isNew) updateDatalist(); // Update autocomplete for new group
                saveData();
                showMessage(`Added to ${groupName}!`);
            } else {
                showMessage('Already in group!');
            }
        }

        // Generate AI Image using Pollinations.ai
        async function generateAIImage(id) {
            const item = allItems.find(i => i.learnable_id === id);
            if (!item) return;
            if (item.image) {
                if (!confirm('Image already exists. Overwrite?')) return;
            }
            const value = item.literal_translation || item.source_value;
            const prompt = encodeURIComponent(`Humorous cartoon illustration of ${value}, exaggerated and memorable, no text, letters, or speech bubbles in the image`);
            const url = `${aiImageApiUrl}${prompt}?model=flux&nologo=true`;
            try {
                showMessage('Generating image...');
                const response = await fetch(url);
                if (!response.ok) throw new Error('API error');
                const blob = await response.blob();
                const reader = new FileReader();
                reader.onload = (e) => {
                    item.image = e.target.result;
                    saveData();
                    renderAllItems();
                    showMessage('AI Image generated!');
                };
                reader.readAsDataURL(blob);
            } catch (e) {
                showMessage('Failed to generate image: ' + e.message, 'red');
            }
        }

        // Generate AI Images for all missing
        async function generateAllMissingImages() {
            const missing = allItems.filter(item => !item.image);
            if (missing.length === 0) return showMessage('All items have images!');
            if (!confirm(`Generate for ${missing.length} items? This may take time.`)) return;
            for (const item of missing) {
                await generateAIImage(item.learnable_id);
                await new Promise(resolve => setTimeout(resolve, 1000)); // 1s delay to avoid rate limits
            }
            showMessage('All missing images generated!');
        }

        // Upload image for item
        function uploadImage(id, file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const item = allItems.find(i => i.learnable_id === id);
                item.image = e.target.result; // Data URL
                saveData();
                renderAllItems();
                showMessage('Image uploaded!');
            };
            reader.readAsDataURL(file);
        }

        // Render groups
        function renderGroups() {
            const container = document.getElementById('groups-container');
            container.innerHTML = '';
            Object.keys(groups).forEach(name => {
                const div = document.createElement('div');
                div.innerHTML = `<h3>${name}</h3>`;
                const ul = document.createElement('ul');
                ul.id = `group-${name}`;
                ul.classList.add('sortable');

                groups[name].forEach(id => {
                    const item = allItems.find(i => i.learnable_id === id);
                    if (item) {
                        const li = document.createElement('li');
                        li.textContent = `${item.source_value} - ${item.target_value}`;
                        li.dataset.id = id;
                        li.classList.add('group-item');
                        li.draggable = true; // Ensure draggable
                        ul.appendChild(li);
                    }
                });

                div.appendChild(ul);

                // Delete group button
                const delBtn = document.createElement('button');
                delBtn.textContent = 'Delete Group';
                delBtn.onclick = () => {
                    delete groups[name];
                    renderGroups();
                    populateGroupSelect();
                    updateDatalist();
                    saveData();
                };
                div.appendChild(delBtn);

                container.appendChild(div);

                // Make sortable
                makeSortable(ul, name);
            });
        }

        // Make list sortable with touch support
        function makeSortable(ul, groupName) {
            let draggedItem = null;

            ul.addEventListener('dragstart', (e) => {
                draggedItem = e.target.closest('li');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', draggedItem.dataset.id);
            });

            ul.addEventListener('dragover', (e) => {
                e.preventDefault();
                const target = e.target.closest('li');
                if (target && target !== draggedItem) {
                    const rect = target.getBoundingClientRect();
                    const next = (e.clientY - rect.top) / rect.height > 0.5;
                    ul.insertBefore(draggedItem, next && target.nextSibling || target);
                }
            });

            ul.addEventListener('dragend', () => {
                updateGroupOrder(ul, groupName);
                draggedItem = null;
            });

            // Touch support
            ul.addEventListener('touchstart', (e) => {
                draggedItem = e.target.closest('li');
                draggedItem.style.opacity = '0.5';
            });

            ul.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const target = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('li');
                if (target && target !== draggedItem) {
                    const rect = target.getBoundingClientRect();
                    const next = (touch.clientY - rect.top) / rect.height > 0.5;
                    ul.insertBefore(draggedItem, next && target.nextSibling || target);
                }
            });

            ul.addEventListener('touchend', () => {
                if (draggedItem) {
                    draggedItem.style.opacity = '1';
                    updateGroupOrder(ul, groupName);
                    draggedItem = null;
                }
            });
        }

        // Update group order after drag
        function updateGroupOrder(ul, groupName) {
            const newOrder = Array.from(ul.querySelectorAll('li')).map(li => Number(li.dataset.id));
            groups[groupName] = newOrder;
            saveData();
        }

        // Populate group select for learning
        function populateGroupSelect() {
            const select = document.getElementById('group-select');
            select.innerHTML = '';
            Object.keys(groups).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }

        // Learning session
        let currentSession = {
            items: [],
            mode: '',
            index: 0,
            correct: 0,
            total: 0,
            flipped: false
        };

        function startSession() {
            const groupName = document.getElementById('group-select').value;
            const mode = document.getElementById('mode-select').value;
            if (!groupName || !groups[groupName].length) return showMessage('No group selected or empty!', 'red');

            currentSession.items = groups[groupName].map(id => allItems.find(i => i.learnable_id === id));
            currentSession.mode = mode;
            currentSession.index = 0;
            currentSession.correct = 0;
            currentSession.total = currentSession.items.length;
            currentSession.flipped = false;

            document.getElementById('flashcard-container').style.display = 'block';
            document.getElementById('session-result').style.display = 'none';
            showCard();
        }

        function showCard() {
            if (currentSession.index >= currentSession.total) {
                const percent = (currentSession.correct / currentSession.total) * 100;
                document.getElementById('session-result').innerHTML = `Session complete! Correct: ${currentSession.correct}/${currentSession.total} (${percent.toFixed(2)}%)`;
                document.getElementById('session-result').style.display = 'block';
                document.getElementById('flashcard-container').style.display = 'none';
                return;
            }

            const item = currentSession.items[currentSession.index];
            const front = document.querySelector('.front');
            const back = document.querySelector('.back');

            // Front based on mode
            front.innerHTML = '';
            if (currentSession.mode === 'image' && item.image) {
                front.innerHTML = `<img src="${item.image}" alt="Image">`;
            } else if (currentSession.mode === 'chinese') {
                front.textContent = item.target_value;
            } else if (currentSession.mode === 'pinyin') {
                front.textContent = item.romanization;
            } else {
                front.textContent = 'No content available';
            }

            // Back with all info
            back.innerHTML = `
                <p><strong>Chinese:</strong> ${item.target_value}</p>
                <p><strong>Pinyin:</strong> ${item.romanization}</p>
                <p><strong>English:</strong> ${item.source_value}</p>
                <p><strong>Literal:</strong> ${item.literal_translation || 'N/A'}</p>
                <h4>Audios:</h4>
                ${item.audio_urls.map(url => `<audio controls src="${url}"></audio>`).join('<br>')}
                <h4>Videos:</h4>
                ${item.video_urls.map(url => `<video controls width="200" src="${url}"></video>`).join('<br>')}
            `;

            front.classList.add('active');
            back.classList.remove('active');
            currentSession.flipped = false;

            document.getElementById('progress').textContent = `Card ${currentSession.index + 1}/${currentSession.total}`;
        }

        function flipCard() {
            if (currentSession.flipped) return;
            document.querySelector('.front').classList.remove('active');
            document.querySelector('.back').classList.add('active');
            currentSession.flipped = true;
        }

        function markCorrect() {
            if (!currentSession.flipped) return showMessage('Flip first!', 'red');
            currentSession.correct++;
            nextCard();
        }

        function markIncorrect() {
            if (!currentSession.flipped) return showMessage('Flip first!', 'red');
            nextCard();
        }

        function nextCard() {
            currentSession.index++;
            currentSession.flipped = false;
            showCard();
        }

        // Initial load
        loadData();
        showSection('import-section'); // Default to first section
    </script>
</body>
</html>
